//Кодирование и декодирование строки ESC и Jump методами
//escape кодирование
fso = new ActiveXObject ("Scripting.FileSystemObject"); //обеспечивает доступ к файловой системе Windows
fh = fso.OpenTextFile("inpute.txt",1,false); // false-открывает готовый файл;  true-создает файл; 1-для чтения; 2-для записи; 8-для добавления (в конец)
s = fh.ReadAll(); // считываем строку
sp=s.split(/\r\n|\r|\n/) //делим строку на подстроки (как записано в исходике с переносами)
dl=sp.length; //длина нашего массива подстрок
a=1 //счетчик
//WSH.echo(s);
fin=""; //строка, в которую записываем закодированн...
e="#"; // эскейп символ
for (var i=0; i<dl;i++){ //идем по элементам массива подстрок
    dlk=sp[i].length; //изнаем длину элемента массива
    stroka=sp[i]; //берем строку- элемент массива
    for (var j=0; j<dlk; j++){//идем по строке-элементу массива
        if ((stroka.charAt(j+1)==stroka.charAt(j)) && (a<126) && (j!=dlk-1)){ //пока рассматрив символ равен следующему; при этом a<126- так как в аски таблице блокнота 127 символов; проверяем, что это не последдний символ (после него ничего не следует)
            a++;// считаем повторки
        }
        else {
            a++;
            if ((a<4)&& (stroka.charAt(j)!=e)){ //если встречается три раза (не кодируем), либо не повторяются
                for ( var t=0; t<a; t++){ //это делаем, чтобы при встрече с тремя\двумя символами выводились все, а не один
                    fin+=stroka.charAt(j); //добавляем этот символ
                }
            }
            if ((a>3)||(stroka.charAt(j)==e)){ // если буков больше трех, либо этот символ- эскейп символ
                fin+=e+ String.fromCharCode(a)+stroka.charAt(j); //записываем в финстроку ескейп символ+ символ из таблицы+ сам символ (который кодируем)
            }
            a=0;// обнуляем счетчик
        }
    }
    fin+="\r\n";//перенос на след строку (чтобы в итоговом файле были такие же строки как в исходном)
}
fh = fso.OpenTextFile("codee.txt", 2, true); // открываем (создаем) файл для записи
fh.WriteLine(fin);// записываем в файл фин строку
fh.Close();// закрываем все это дело наконец-то


//escape декодирование
fso = new ActiveXObject ("Scripting.FileSystemObject"); //обеспечивает доступ к файловой системе Windows
fh = fso.OpenTextFile("codee.txt",1,false); // false-открывает готовый файл;  true-создает файл; 1-для чтения; 2-для записи; 8-для добавления (в конец)
s = fh.ReadAll(); // считываем строку
sp=s.split(/\r\n|\r|\n/) //делим строку на подстроки (как записано в исходике с переносами)
dl=sp.length; //длина нашего массива подстрок
a=1 //счетчик
//WSH.echo(s);
fin=""; //строка, в которую записываем закодированн...
e="#"; // эскейп символ
for (var i=0; i<dl;i++){ //идем по элементам массива подстрок
    dlk=sp[i].length; //изнаем длину элемента массива
    stroka=sp[i]; //берем строку- элемент массива
    for (var j=0; j<dlk; j++){ //идем по строке-элементу массива
        if (stroka.charAt(j)!=e){// если элемент не эскейп символ то записываем в финстроку
            fin+=stroka.charAt(j)
        }
        else {
            c= stroka.charAt(j+1).charCodeAt(0) //смотрим какой он в таблице (число повторений)
            for ( var t=0; t<c; t++) //пока счетчик т не равен числу повторений записывем буковку в строчечку
            {
                fin+=stroka.charAt(j+2); //добавляем этот символ
            } //перескакиваем на два сивола вперед, так как первый эскейп, второй кол-во повторений
            j+=2;
        }
    }
    fin+="\r\n";//перенос на след строку (чтобы в итоговом файле были такие же строки как в исходном)
}
fh = fso.OpenTextFile("outpute.txt", 2, true); // открываем (создаем) файл для записи
fh.WriteLine(fin);// записываем в файл фин строку
fh.Close();// закрываем все это дело наконец-то

//jumpc
fso = new ActiveXObject ("Scripting.FileSystemObject"); //обеспечивает доступ к файловой системе Windows
fh = fso.OpenTextFile("inputj.txt",1,false); // false-открывает готовый файл;  true-создает файл; 1-для чтения; 2-для записи; 8-для добавления (в конец)
s = fh.ReadAll(); // считываем строку
sp=s.split(/\r\n|\r|\n/) //делим строку на подстроки (как записано в исходике с переносами)
dl=sp.length; //длина нашего массива подстрок
a=1; //счетчик для повторок
b=1; // счетчи для неповторок
fin=""; //строка, в которую записываем закодированн...
strn="";
//WSH.Echo(sp)
for (var i=0; i<dl;i++){ //идем по элементам массива подстрок
    dlk=sp[i].length; //изнаем длину элемента массива
    stroka=sp[i]; //берем строку- элемент массива
    for (var j=0; j<dlk; j++){ //идем по строке-элементу массива
        if ((stroka.charAt(j)==stroka.charAt(j+1)) && (a<63) && (j!=dlk-1)){
            a++;// считаем повторки
        }
        else {
            a++;
            if ((a>1)){
                fin+=String.fromCharCode(a)+stroka.charAt(j); //записываем в финстроку ескейп символ+ символ из таблицы+ сам символ (который кодируем)
            }
            a=0;// обнуляем счетчик
        }

        {
            if ((stroka.charAt(j)!=stroka.charAt(j+1))&&((b<63)&& (j!=dlk-1))){
                b++;// считаем повторки
                strn+=stroka.charAt(j);
            }
            else {
                strn+=stroka.charAt(j);
                if ((b>1))
                {
                    fin+=String.fromCharCode(63+b)+strn;
                }
                strn=""; //записываем в финстроку ескейп символ+ символ из таблицы+ сам символ (который кодируем)
                b=0;// обнуляем счетчик
            }
        }
    }
    fin+="\r\n";//перенос на след строку (чтобы в итоговом файле были такие же строки как в исходном)
}
//WSH.Echo(fin)
fh = fso.OpenTextFile("codej.txt", 2, true); // открываем (создаем) файл для записи
fh.WriteLine(fin);// записываем в файл фин строку
fh.Close();// закрываем все это дело наконец-то

//jump декодирование
fso = new ActiveXObject ("Scripting.FileSystemObject"); //обеспечивает доступ к файловой системе Windows
fh = fso.OpenTextFile("codej.txt",1,false); // false-открывает готовый файл;  true-создает файл; 1-для чтения; 2-для записи; 8-для добавления (в конец)
s = fh.ReadAll(); // считываем строку
sp=s.split(/\r\n|\r|\n/) //делим строку на подстроки (как записано в исходике с переносами)
dl=sp.length; //длина нашего массива подстрок
a=1; //счетчик для повторок
b=1; // счетчи для неповторок
fin=""; //строка, в которую записываем закодированн...
strn="";
//WSH.Echo(sp)
for (var i=0; i<dl;i++){ // //идем по элементам массива подстрок
    dlk=sp[i].length; //изнаем длину элемента массива
    stroka=sp[i]; //берем строку- элемент массива
    for (var j=0; j<dlk;j){ // ; j++ идем по строке-элементу массива
        c= stroka.charAt(j).charCodeAt(0);
        if (c>64){
            fin+=stroka.slice(j+1,128-c)

            j+=(128-c)
        }
        if (c<65){
            for ( var t=0; t<c; t++) //пока счетчик т не равен числу повторений записывем буковку в строчечку
            {
                fin+=stroka.charAt(j+1); //добавляем этот символ
            }
            j+=2 //перескакиваем на два сивола вперед, так как первый эскейп, второй кол-во повторений
        }
    }
    fin+="\r\n";//перенос на след строку (чтобы в итоговом файле были такие же строки как в исходном)
}
//WSH.Echo(fin)
fh = fso.OpenTextFile("outputj.txt", 2, true); // открываем (создаем) файл для записи
fh.WriteLine(fin);// записываем в файл фин строку
fh.Close();// закрываем все это дело наконец-то